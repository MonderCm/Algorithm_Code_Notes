**Kadane算法**​ 是一种高效的动态规划算法，用于在**一维数组**中找到**连续子数组的最大和**。它的核心思想是：通过遍历数组并维护两个关键变量，逐步更新当前的最大子数组和，最终得到全局最大值。

**最纯粹的模板题:**[P1115 最大子段和 - 洛谷](https://www.luogu.com.cn/problem/P1115)

**当前元素**:now(如果是数组，保证arr[0]非空)
**当前最大和(current_sum)**:表示以当前元素结尾的连续子数组的最大和
**全局最大和(maxx)**:记录遍历过程中遇到的最大子数组和

**核心逻辑**:对于每个元素，选择是否将当前元素加入之前的子数组，或者以当前元素作为新的子数组起点
	  ==current_max=max(now,current_max+now)==;

**算法步骤**
1. ​**初始化**​
    - `current_max` 和 `maxx 设为数组第一个元素的值。
2. ​**遍历数组**​
    - 从第二个元素开始，依次更新 `current_max` 和 `maxx`。
3. ​**更新规则**​
    - `current_max = max(now, current_max +now)`
    - `max_so_far = max(maxx, current_max)`


**示例演示**
假设数组为：`[-2, 1, -3, 4, -1, 2, 1, -5, 4]`  
逐步计算过程如下：

| 元素            | -2  | 1   | -3  | 4   | -1  | 2   | 1   | -5  | 4   |
| ------------- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| `current_max` | -2  | 1   | -2  | 4   | 3   | 5   | 6   | 1   | 5   |
| `maxx`        | -2  | 1   | 1   | 4   | 4   | 5   | 6   | 6   | 6   |
**最终结果**​：最大子数组为 `[4, -1, 2, 1]`，和为 ​**6**
人话翻译一遍:
每次current_max加上arr[i],然后判断当前元素大还是加上新元素的子数组大进而更新current_max，而maxx始终保持最大和
如果当前元素更大则以当前元素为子数组的新起点再次去计算最优解

实现代码:
```cpp
int kadane(const vector<int>& arr) {
    int current_max = arr[0];
    int maxx = arr[0];
    for (int i = 1; i < arr.size(); ++i) {
        current_max = max(arr[i], current_max + arr[i]);
        maxx = max(maxx, current_max);
    }
    return maxx;
}
```
**时间复杂度分析**:
**一维数组**​：Kadane算法的时间复杂度为 O(n)
**二维矩阵**​：
- 枚举所有行组合的时间复杂度为 O(n2)。
- 每次行组合需要 O(n) 时间压缩列和并调用Kadane算法。
- 总时间复杂度为 O(n3)，在 n=120 时完全可行（计算量约 1.7 百万次）。
- **操作次数估算**​：
- 当 n=200 时：200³ = ​**8,000,000**​ 次操作
- 当 n=500 时：500³ = ​**125,000,000**​ 次操作
- 当 n=1000 时：1000³ = ​**1,000,000,000**​ 次操作
- **实际处理能力**​：
- 假设C++代码每秒可处理 1×108 次操作：
    - n=500 时约需 ​**1.25秒**​（勉强通过时间限制）
    - n=600 时约需 ​**216秒**​（严重超时）