[牛客竞赛_ACM/NOI/CSP/CCPC/ICPC算法编程高难度练习赛_牛客竞赛OJ](https://ac.nowcoder.com/acm/contest/107500#rank/%22onlyMyFollow%22%3Atrue)

## 第一题：判断是否为 2.5 的倍数

**题意**  
给定整数 \(n\)，判断它是否能被 2.5 整除。

**关键思路**  
- 既然要判断能否被 2.5 整除，则必然能被 5 整除且结果为偶数；  
- 但题目中简化为只需判断能否被 5 整除（因为 \(n\) 为整数，若 \($n \bmod 5=0$\) 则 $(\frac{n}{5})$ 也是整数；再判断这个整数是否为偶数可用位运算或 \($\bmod2$\)，但通常题目允许简化为只判断 $(n\%5==0)$。

**示例代码**  
```cpp
if (n % 5 == 0)
    cout << "Yes\n";
else
    cout << "No\n";
   
```
## 第二题：消除 “25” 子序列

**题意**  
给定由字符 ‘2’ 和 ‘5’ 组成的长度为 n 的字符串，允许交换任意两位，问最少需要多少次交换能使字符串中不存在字符子序列 “25”。

**关键思路**

1. 统计字符串中所有的 ‘5’ 个数，记为 $cnt5$；
    
2. 理想状态下，前 $cnt5$ 个位置都放 ‘5’，其余全放 ‘2’；
    
3. 在前 $cnt5$ 个位置中，每遇到一个 ‘2’ 就需要一次交换，将其与后面某个 ‘5’ 交换；
    
4. 答案即为前 $cnt5$个位置中 ‘2’ 的数量。
    

**时间复杂度**

- 统计字符个数：O(n)
    
- 计算前缀中 ‘2’ 的数量：$O(cnt5)≤O(n)$
    
- **总：O(n)

## 第三题：重排使加权和最大

**题意**  
给定两个长度为 n 的数组 a 和 b，定义数组
$$ c_i = a_i \times b_i \times i $$

对 b 进行任意重排，求最大的 $$ \max \sum_{i=1}^{n} c_i $$

**关键思路（重排不等式）**

1. 将每个位置的“权重”定义为 $w_i=a_i \cdot i$；
    
2. 按 $w_i$​ 升序对所有下标排序，同时将 b 升序排序；
    
3. 将第 k小的 b 值分配给第 k 小的 w 对应位置，即可使 ​ 最大。
    

**步骤**

1. 计算 $w_i = a_i \cdot i$，并记录原始下标；
    
2. 对 ${w_i}$ 和 ${b_i}$ 各自升序排序；
    
3. 重排后，按排序对应位置赋值；
    
4. 输出重排后的 b 数组。
    

**时间复杂度**

- 排序各 O(nlog⁡n)，其他线性操作 O(n)
    
- **总：O(nlog⁡n)**

## 第四题：分段最小化 “25” 子序列最大次数

**题意**  
给定 n 个字符串（或数字拼接字符串），需将它们按原序分成 k 段连续子区间，使得每段中字符子序列 “25” 的出现次数的最大值最小，求该最小的最大值。

**关键思路**

1. **预处理**
    
    - 对第 iii 个字符串计算：
        
        - cnt2：‘2’ 的个数；
            
        - cnt5：‘5’ 的个数；
            
        - cint[i]：该段内部 “25” 的逆序对数（按扫描统计）。
            
2. **二分答案**
    
    - 枚举最大允许值 X；
        
    - 通过贪心从左到右扫描，将当前段 “25” 总数（含跨字符串累积的组合）累计，如超过 X 则开启新段；
        
    - 若所需段数 ≤k，则 X 可行，否则增大 X。
        
3. **贪心检验**
    
    - 维护已选段内的累计 “2” 数量 `pre2`，当前段 “25” 数量 `sum`；
        
    - 处理第 i 个字符串时，新增 “25” 数量为
        
	     cost[i]+pre2×cnt5[i] 
        
    - 若 `sum + 新增 > X`，则分一段，新段重置 `pre2=cnt2[i]`、`sum=cint[i]`。

**时间复杂度**

- 预处理（字符串统计）：O(nL)
    
- 二分范围宽度为 S，每次检查 O(n)，共 O(log⁡S) 次
    
- **总：O(nL+nlog⁡S)**
