**题目描述**

众所不周知，Tk 是坤的真爱粉，所以 Tk 对所有与 **25** 有关的东西都极其敏感。
一天邪恶的黑粉给 Tk 一个长度为 $n$ 的数组 $\{a_1, a_2, \ldots, a_n\}$，Tk 找到了你，希望你将数组分割成 $k$ 个非空子区间 $[l_j, r_j]$，其中：
- $l_1 = 1$
- $r_k = n$
- 对于任意 $1 < j \leq k$，都有 $r_{j-1} + 1 = l_j$ ->**手动带入几个j值，可以发现题目要求区间是连续的**

你要 **尽可能降低** 所有子区间中 **字符子序列 `25`** 的 **最大出现次数**。  
请输出你操作后所有子区间中字符子序列 `25` 的最大出现次数的**最小值**。

**注**：
字符子序列：在本题中，你可以理解为将数组区间中所有数字按顺序拼接成一个字符串，该字符串中的子序列即为该数组区间的字符子序列。例如，数组 $\{22, 55\}$ 按顺序拼接成字符串 `2255`，该字符串中有 **4** 个子序列为 `25`，则该数组的字符子序列 `25` 个数为 4。

---

**输入描述**

第一行输入两个整数 $n, k$（$1 \leq k \leq n \leq 2 \times 10^5$），表示数组大小以及要分割的子区间个数。

第二行输入 $n$ 个整数 $a_i$（$1 \leq a_i \leq 10^9$），表示数组 $a$。

---

**输出描述**

输出一个整数，表示 **最小化子区间中字符子序列 `25` 出现次数的最大值**。

---

**一眼丁真**：看到题目中要求字符**25**出现的最大次数最小就可以想到，这题需要用的是**二分答案**,并且结合**贪心**来合理分段，以下是题目思路:
1. ==预处理:==因为题目要求的是连续区间中**25***(不一地是相邻的)字符串的数量，并且题目给出的是含有25的子数组，因此先统计每个子数组中的2,5的数量来计算每段中**25**字符串的数量，并且计算的2,5的数量后面可以用来计算将两个或者多子数组链接起来时候总共的**25**字符串的数量

2. ==二分答案:==题目要求在k段中，求最小化子区间中字符子序列**25**出现次数的最大值，意思就是说将n个区间连接起来，分成k个连续子区间，k个子区间的最大值在所有分法中最小，因此这个题目二分枚举的就是k个子区间中可能的**25**序列出现的次数
3. ==二分答案的区间:==因为枚举的是**25**出现的次数，因此需要初始化二分区间，l毋庸置疑是$l_0=0$,而r的值则应该是所有**25**可能出现的值`(最极端的情况，当k=1时，r边界就是所有的25子序列)`==(任何分成 ≥2 段的方案，都会丢失跨段的 ‘2...5’ 配对，因而总数 ≤ R)== -> ==单独子区间出现25子序列的个数+相邻子区间连接起来时25子区间的数量
==
4. ==贪心算法:==结合上述描述，当我们得到了一个**mid**可能值，然后从`0~n-1`线性扫可能情况，如果合法并且<=mid，当大于mid的时候分段，如果段数cnt>k则`return false`，情况非法，枚举下一个mid

代码部分:
```cpp
void solve() {  
    cin >> n >> k;  
    vector<string> a(n);  
    for(int i = 0; i < n; i++){  
        cin >> a[i];  
    }  
    vector<int> cnt2(n), cnt5(n);  
    vector<ll> cint(n);  
    for(int i = 0; i < n; i++){  
        ll sum2 = 0, cost = 0;  
        for(char c:a[i]){  
            if(c == '2') sum2++;  
            else if(c == '5') cost += sum2;  
        }  
  
        cnt2[i] = count(a[i].begin(),a[i].end(),'2');  
        cnt5[i] = count(a[i].begin(),a[i].end(),'5');  
        cint[i] = cost;  
    }  
    auto check = [&](ll x) {  
        int ans = 1;  
        ll pre = 0, pre_sum = 0;  
        for(int i = 0; i < n; i++){  
            if(cint[i] > x) return false;  
            ll pre_add = cint[i] + pre * cnt5[i];  
            if(pre_sum + pre_add <= x){  
                pre_sum += pre_add;  
                pre += cnt2[i];  
            } else{  
                ans++;  
                if(ans > k) return false;  
                pre = cnt2[i], pre_sum = cint[i];  
            }  
        }  
        return true;  
    };  
  
    ll l = 0, r = 0, pre = 0;  
    for(int i = 0; i < n; i++){  
        r += cint[i] + pre * cnt5[i];  
        pre += cnt2[i];  
    }  
  
    ll ans = r;  
    while(l <= r){  
        int mid = l + r >> 1;  
        if(check(mid)){  
            ans = mid;  
            r = mid - 1;  
        } else  
            l = mid + 1;  
    }  
    cout << ans << endl;  
}
```
### 复杂度分析:
**预处理阶段复杂度分析​**​
1. ​**​输入与字符统计​**​
    - 输入 `n` 个字符串，每个字符串遍历一次统计 `'2'` 和 `'5'` 的数量，并计算 `cint[i]`（每个字符串的逆序对成本）。
    - 时间复杂度：​**​O(nL)​**​，其中 `L` 为字符串的平均长度。
        - `count(a[i].begin(), a[i].end(), '2')` 和 `count(a[i].begin(), a[i].end(), '5')` 各需 O(L) 时间
            
            1
            
            9
            
            。
        - 遍历字符串计算 `cint[i]` 同样需 O(L) 时间
            
            1
            
            。

---
 ​**二分查找阶段复杂度分析​**​
1. ​**​二分查找框架​**​
    
    - 初始确定二分范围 `r` 的循环：O(n) 时间
        
        1
        
        。
    - 二分查找次数为 ​**​O(log S)​**​，其中 `S` 是最大可能的成本值（初始 `r` 的总和）。
        - 每次二分调用 `check(mid)` 函数
            
            1
            
            6
            
            。
2. ​**​`check` 函数的复杂度​**​
    - `check` 函数遍历所有 `n` 个元素，每次操作是 O(1)（判断和累加）。
    - 时间复杂度：​**​O(n)​**​ 每次调用。
    - 综上，二分阶段总复杂度：​**​O(n log S)​**​

---
**总时间复杂度​**​
- ​**​整体复杂度​**​：​**​O(nL + n log S)​**​。
    - 预处理阶段主导项为 $O(nL)$，二分阶段主导项为 $O(n log S)$。
    - 若字符串长度 `L` 较小，可近似为 ​$O(n log S)​$；若 `L` 较大（如与 `n` 同阶），则需保留 $O(nL)$ 项

### 代码片段分析:

可能相对难理解点的就是这个吧:
```cpp
ll l = 0, r = 0, pre = 0;  
    for(int i = 0; i < n; i++){  
        r += cint[i] + pre * cnt5[i];  
        pre += cnt2[i];  
    }  

```
cint[i]表示的是第i个子数组中25的数量
pre表示的是从第二个子区间开始，连接后面的子区间，计算与后面子区间新构成的25字符串，因此r最终得到的就是总共的25字符串的数量

==贪心策略讲解:==
代码部分:
```cpp
auto check = [&](ll x) {  
    int ans = 1;  
    ll pre = 0, pre_sum = 0;  
    for(int i = 0; i < n; i++){  
        if(cint[i] > x) return false;  
        ll pre_add = cint[i] + pre * cnt5[i];  
        if(pre_sum + pre_add <= x){  
            pre_sum += pre_add;  
            pre += cnt2[i];  
        } else{  
            ans++;  
            if(ans > k) return false;  
            pre = cnt2[i], pre_sum = cint[i];  
        }  
    }  
    return true;  
};

```
1. pre_add表示预添加的25字符串的数量
2. pre_sum表示扫到第i个子数组时，总共的25字符串数量，如果加上pre_add>x则分段，以当前cint[i]为新节点开始下一段的判断
3. 判断ans是否>k，如果大于，则mid答案不合法
