[P1387 最大正方形 - 洛谷](https://www.luogu.com.cn/problem/P1387)

基础做法:前缀和+暴力枚举
优化=>动态规划

前缀和+暴力枚举做法:
思路为：枚举边长+右下角坐标

```cpp
if(!flag){  //如果数组中没有1，直接结束
    cout << 0 << endl;  
    return 0;  
}  
int l = 2, ans = 1;//边长最短为单个子区间，初始化为1  
while(l <= min(n,m)){ //枚举边长  
    for(int i = l; i <= n; i++){ //枚举右下角坐标  
        for(int j = l; j <= m; j++){  
            int s = pre[i][j] - pre[i - l][j] - pre[i][j - l] + pre[i - l][j - l];  
            if(s == l * l){ //题目要求最大正方形，所以s面积内必须全部为1 
                ans = max(ans,l);  
            }  
        }  
    }  
    l++;  
}  
cout << ans << endl;

```
**时间复杂度:**
1. ​**输入和前缀和预处理**​：
    - 两重循环遍历整个矩阵，时间复杂度为 ​**O(nm)​**。
    - 预处理二维前缀和数组 `pre`，每个元素计算需要 O(1) 时间，总时间为 ​**O(nm)​**。
2. ​**全1正方形搜索**​：
    - 外层 `while` 循环枚举边长 `l`，从 `2` 到 `min(n, m)`，最多循环 `k` 次（`k = min(n, m)`）。
    - 内层两重循环遍历所有可能的右下角坐标 `(i, j)`，遍历次数为 `(n - l + 1) * (m - l + 1)`。
    - 对于每个 `l`，内层循环的时间为 ​**O((n - l)(m - l))​**。
    - 总时间复杂度为 ​**Σ[(n - l)(m - l)]​**​（`l` 从 2 到 `k`），最坏情况下为 ​**O(k³)​**​（当 `n ≈ m ≈ k` 时）。
- ​**最坏情况**​：当 `n = m = k`，总时间为 ​**O(k³)​**。
- 例如，若 `n = m = 1000`，总操作数约为 `1000³ = 1e9`，远超时间限制（1秒通常只能处理约 `1e8` 次操作）。

