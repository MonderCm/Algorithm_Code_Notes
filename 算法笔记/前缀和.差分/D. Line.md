[Problem - D - Codeforces](https://codeforces.com/contest/1722/problem/D)
**算法标签:**
`贪心（greedy）`
`排序（sortings)
`1100 🙂`

---
**Codeforces**的题目确实巧妙呀~还是做少了捏~
这道题目在问:
- 你有 n 个人排成一排，第 i 个人要么朝左看（`L`），要么朝右看（`R`）。如果他朝左，看得到他左边所有人；如果朝右，看得到他右边所有人。把每个人所看到的人数加起来，就得到这一排的“价值”。
    
- 现在，你可以**改变**最多 k 个人的朝向（从 `L` 变 `R` 或从 `R` 变 `L`）。对于每个 $k=1,2,…,n$，问：在允许最多翻转 k 次的情况下，能把这排人的“价值”最大化到多少？

换句话说，就是要对每个 k 计算一次：在至多进行 k 次朝向翻转后，这一排列的累计可见人数最高能达到几。

---
**思路解析**:
对于长度为 n 的队列，编号从 0 到 n−1。第 i 个人：
- 如果朝左看（`L`），他的可见人数就是左边的人数：i。
- 如果朝右看（`R`），他的可见人数就是右边的人数：$(n−1−i)$。

初始总可见数为:
$$
S_0 = \sum_{i=0}^{n-1} \left[ s_i = \text{L? } i : (n - 1 - i) \right]
$$

如果将第 i 个人的朝向翻转，那么：

- 原来是 `L`（贡献 i）翻成 `R` 后贡献变为 $(n−1−i)$，增益为 $(n−1−i)−i=n−1−2i$。
    
- 原来是 `R`（贡献 $n−1−i$）翻成 `L` 后贡献变为 i，增益为 $i−(n−1−i)=2i−(n−1)$。
    

记第 i 个人的“翻转增益”为 $gi$。只有当 $gi>0$ 时翻转才有好处。

1. 先算出 $S0$ 和每个人的 $gi$；
    
2. 把所有 gi>0 的增益收集到数组 `pos`，并按降序排序；
    
3. 建前缀和 `prefix`，其中:$$
\text{prefix}[k] = \sum_{j=1}^k \text{pos}[j]
$$
4. 对于每个 $k=1…n$，我们至多做 k 次翻转，最优是选前 $min⁡(k,m)$个正增益：

   ans[k]=S0​+prefix[min(k,m)]   
 
	 其中 m= `pos.size()`。
 

这样时间复杂度 $O(nlog⁡n)$，空间 O(n)，足以应对 $\sum n \leqslant 2 \cdot 10^5$的要求。

---

排序+前缀和:
```cpp
int ans = 0; //初始可见总人数  
    vector<int> a(n);  
    for(int i = 0; i < n; i++){  
        if(s[i] == 'L'){  
            ans += i;  
            a[i] += n - 1 - 2 * i;  
        } else{  
            ans += n - 1 - i;  
            a[i] = i - (n - 1 - i);  
        }  
    }  
    sort(a.begin(),a.end(),greater());  
    for(int i = 0; i < n; i++){  
        ans += max(0LL,a[i]);//前缀和，只处理贡献为正的操作  
        cout << ans << " \n"[i == n - 1];  
    }  
}
```
