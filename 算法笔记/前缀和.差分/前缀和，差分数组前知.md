**前缀和是一种==预处理==技术，用于快速计算数组的区间和或矩阵的子矩阵和。以下是常见的一维和二维前缀和的表达形式，分别用静态数组和 `vector` 实现。**

在写前缀和前需要弄清楚是以==1==为下标还是以==0==为下标

### 一维前缀和

#### 1. 静态数组形式

```cpp
// 原始数组（下标1~n）
int arr[] = {0, 1, 3, 5, 7, 9};  // arr[1]=1, arr[5]=9
int n = 5;  // 实际有效元素个数

// 前缀和数组（下标1~n）
int prefix[n + 1];  // 多一个位置
prefix[0] = 0;      // 边界值
for (int i = 1; i <= n; i++) {
    prefix[i] = prefix[i - 1] + arr[i];
}

// 查询区间和 [l, r]（闭区间，1<=l<=r<=n）
int query(int l, int r) {
    return prefix[r] - prefix[l - 1];
}
```
​**解释**​：
- `prefix[i]` 表示前 `i` 个元素的和（即 `arr[0] + arr[1] + ... + arr[i-1]`）。
- 原数组 `arr` 的有效下标为 `1~n`，前缀和数组 `prefix` 的下标为 `0~n`
- 递推公式：`prefix[i] = prefix[i-1] + arr[i]`（下标1开始累加）
- 查询区间 `[l, r]` 的和时，公式为 `prefix[r] - prefix[l-1]`。

---

#### 2. vector形式

```cpp
vector<int> arr = {0, 1, 3, 5, 7, 9};  // arr[1]~arr[5]
int n = arr.size() - 1;  // 有效元素个数

vector<int> prefix(n + 1, 0);  // prefix[0]~prefix[n]
for (int i = 1; i <= n; i++) {
    prefix[i] = prefix[i - 1] + arr[i];
}

// 查询区间和 [l, r]
int query(int l, int r) {
    return prefix[r] - prefix[l - 1];
}
```

​**解释**​：

- `vector` 的动态分配更灵活，适合未知大小的数组。
- 初始化时直接设置大小为 `n + 1`，并填充初始值 `0`。


### 二维前缀和（下标1开始）

#### 1. 静态数组形式

```cpp
// 原始二维数组（下标1~rows, 1~cols）
int matrix[4][4] = {  // matrix[1][1]~matrix[3][3]
    {0, 0, 0, 0},
    {0, 1, 2, 3},
    {0, 4, 5, 6},
    {0, 7, 8, 9}
};
int rows = 3, cols = 3;

// 前缀和数组（下标1~rows, 1~cols）
int prefix[rows + 1][cols + 1];  // 多一行一列
memset(prefix, 0, sizeof(prefix));

for (int i = 1; i <= rows; i++) {
    for (int j = 1; j <= cols; j++) {
        prefix[i][j] = matrix[i][j] + prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1];
    }
}


// 查询子矩阵和 [(x1, y1) 到 (x2, y2)]（1<=x1<=x2<=rows, 1<=y1<=y2<=cols）--> 容斥原理
int query(int x1, int y1, int x2, int y2) {
    return prefix[x2][y2] - prefix[x1 - 1][y2] - prefix[x2][y1 - 1] + prefix[x1 - 1][y1 - 1];
}
```

​**解释**：

- 原矩阵 `matrix` 的有效下标为 `(1,1)` 到 `(rows, cols)`。
- 递推公式：`prefix[i][j] = matrix[i][j] + prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1];`
- 查询时使用==容斥原理==计算子矩阵和

---

#### 2. vector形式

```cpp
vector<vector<int>> matrix = {  // matrix[1][1]~matrix[3][3]
    {0, 0, 0, 0},
    {0, 1, 2, 3},
    {0, 4, 5, 6},
    {0, 7, 8, 9}
};
int rows = 3, cols = 3;

vector<vector<int>> prefix(rows + 1, vector<int>(cols + 1, 0));
for (int i = 1; i <= rows; i++) {
    for (int j = 1; j <= cols; j++) {
        prefix[i][j] = matrix[i][j] + prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1];
    }
}

// 查询子矩阵和
int query(int x1, int y1, int x2, int y2) {
    return prefix[x2][y2] - prefix[x1 - 1][y2] - prefix[x2][y1 - 1] + prefix[x1 - 1][y1 - 1];
}
```

