这道题第一眼看过去可能会认为是博弈，但其实不然，题目的意思是Alice,Bob两个人在n个整数中进行擦拭游戏，并且有以下操作：
- 爱丽丝从黑板上选择一个整数并擦除。我们把爱丽丝选择的整数称为 a 。
- 鲍勃从黑板上选中一个整数并擦除。我们称鲍勃选择的整数为 b 。
- 如果是 $a+b=k$ ，则在得分上加上 1 。
爱丽丝的目标是最小化得分，而鲍勃的目标是最大化得分。

本人刚开始错误的理解(可跳过)：
刚看这一道题的时候我以为就是将数组排序，然后Alice从最大的数字开始一个个向下标减小的方向移，这里假设为`nums[i]`，Bob从最小的数字开始下标增大的方向移，这里假设为`nums[j]`，移动的前提条件是$a+b=k$，如Alice该位置的值如果>=k时，Alice的下标就-1，再判断，如果`nums[i]+nums[j]==k`，则保持i不变，去移动j，然后再判断是否和为k，但是其实一点道理都没有，反而会导致漏解，因为Alice是使目标最小化得分，她要做的就是选择与Bob不是互补的那个数，并不是说Alice就要按照大小从元素大的往下选，我靠我现在写题解也感觉自己当时为什么要这么想，好蠢啊！！！题做少了喵~

正确的题解：
其实这道题可以换个角度想，也就是先计算这个数组中有多少对可以凑成k并记录下来(ans)，然后min(ans,n/2)输出正确答案，是不是很简单，这里可以使用map快速映射然后遍历找到答案。

主播觉得这个题跟[P1102 A-B 数对 - 洛谷](https://www.luogu.com.cn/problem/P1102)数对这道题其实是有异曲同工之妙的~

下面是主播错误的逻辑代码:
```cpp
for(int i = 0; i < n; i++){  
    if(p[k - q[i]] && p[q[i]]){  
        ans++;  
        p[k - q[i]]--;  
        p[q[i]]--;  
    }  
}

```
主播当时改正思路后的想法是先映射每个元素，然后遍历每个元素如果存在相应的补值，则补值和当前元素的键值-1，但是该代码在处理相同元素时会存在错误,如:
`n=1` `k=1`
`nums[1]=1`
则ans=0，而我的代码跑出来的答案是ans=1，因为这里需要对$x=k-x$的情况进行特判，下面的更改后的正确代码

```cpp
        sort(q.begin(), q.end());
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            int comp = k - q[i];
            if (p.count(q[i]) && p.count(comp)) {
                if (p[q[i]] > 0 && p[comp] > 0) {
                    // 处理同一元素的补数是自身的情况
                    if (comp == q[i]) {
                        if (p[comp] >= 2) {
                            ans++;
                            p[comp] -= 2;
                        }
                    } else {
                        ans++;
                        p[q[i]]--;
                        p[comp]--;
                    }
                }
            }
        }
        cout << ans << '\n';
    }
    return 0;
}


```
~~虽然本题可以这样结束，但是有一个疑问就是，题目是一个博弈题目，就是说Alice先手，她会故意挑选并删除关键元素来破坏匹配，使Bob可选的元素减少，如一个反例:~~
- ~~**参数**：~~
    ~~n=6,k=5,~~
    ~~q=[1,2,2,3,3,4]~~ 
- ~~**初始计数**：~~
    ~~p[1]=1,  p[2]=2,  p[3]=2,  p[4]=1;~~
- ~~**你的代码会算出**：~~  
    ~~1+4 → 1 对~~  
    ~~2+3 → 2 对~~  
    ~~总共 `ans = 3`~~
~~但在真正的最优对抗博弈中，Alice 会用两次先手彻底破坏其中两个配对—~~
1. ~~**第1轮**~~
    - ~~Alice 删除 a=2（一张“2”）。~~
        
    - ~~Bob 删除 b=3，得分+1（因为2+3=5）。~~  
        ~~剩余：1,2,3,41,2,3,41,2,3,4~~
        
2. ~~**第2轮**~~
    - ~~Alice 删除 a=1。~~
        
    - ~~Bob 删除 b=3，得分不变（1+3≠5）。~~  
        ~~剩余：2,42,42,4~~
3. ~~**第3轮**~~
    - ~~Alice 删除 a=4。~~
        
    - ~~Bob 删除 b=2，得分不变（4+2≠5）。~~

~~最终 Bob 只能得到 **1** 分，而不是 3 分。~~
是我傻还是Bob傻？**在这个游戏中，鲍勃拥有所有的权力，因为爱丽丝挑选数字的顺序并不重要，因为鲍勃总是可以挑选出最佳数字来给自己加分。因此，我们可以忽略爱丽丝，从鲍勃的角度来玩这个游戏。**

下面正确代码部分：
为什么检查完每个元素后不把相应的键值减掉？
因为每个元素只检查一次，因此不会导致重复情况出现

```cpp
 vector<int> q(n);  
    map<int , int> p;  
    for(int i = 0; i < n; i++){  
        cin >> q[i];  
        p[q[i]]++;  
    }  
    int ans = 0;  
    for(auto it = p.begin(); it != p.end(); ++it){  
        int num = it->first;  
        int num1 = k - num;  
        if(num1 < num) continue; //这里是为了防止重复配对
		
        if(p.count(num1)){ //检查键是否存在  
            if(num == num1){  
                ans += it->second / 2;  
            } else{  
                ans += min(it->second,p[num1]);  
            }  
        }  
    }  
    cout << min(ans,n / 2) << endl;  
}
```
**复杂度分析**:
1 ​**输入处理与频率统计**
```cpp
for(int i = 0; i < n; i++) {
        cin >> q[i];
        p[q[i]]++;  // map的插入操作是O(log m), m为不同元素的数量
    }。  
```
- 时间复杂度：`O(n log m)`，其中 `m` 是数组中不同元素的数量（`m ≤ n`）。
- 原因：`map`（红黑树实现）的插入和更新操作的时间复杂度是 `O(log m)`，需要执行 `n` 次
2. ​**遍历频率表计算配对数量**​
    ```cpp
    for(auto it = p.begin(); it != p.end(); ++it) {
        int num = it->first;
        int num1 = k - num;
        if (num1 < num) continue;
        if (p.count(num1)) {  // map的查找操作是O(log m)
            // ...
        }
    }
    ```
- 时间复杂度：`O(m log m)`，其中 `m` 是不同元素的数量。
- 原因：遍历所有 `m` 个不同元素，每次查找补数 `num1` 的操作需要`O(log m)` 时间。
3. ​**总时间复杂度**​
    - `O(n log m) + O(m log m) = O((n + m) log m)`。
    - 最坏情况下（所有元素不同，`m = n`），时间复杂度为 `O(n log n)`。