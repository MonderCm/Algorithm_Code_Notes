这道题第一眼看过去可能会认为是博弈，但其实不然，题目的意思是Alice,Bob两个人在n个整数中进行擦拭游戏，并且有以下操作：
- 爱丽丝从黑板上选择一个整数并擦除。我们把爱丽丝选择的整数称为 a 。
- 鲍勃从黑板上选中一个整数并擦除。我们称鲍勃选择的整数为 b 。
- 如果是 $a+b=k$ ，则在得分上加上 1 。
爱丽丝的目标是最小化得分，而鲍勃的目标是最大化得分。

本人刚开始错误的理解(可跳过)：
刚看这一道题的时候我以为就是将数组排序，然后Alice从最大的数字开始一个个向下标减小的方向移，这里假设为`nums[i]`，Bob从最小的数字开始下标增大的方向移，这里假设为`nums[j]`，移动的前提条件是$a+b=k$，如Alice该位置的值如果>=k时，Alice的下标就-1，再判断，如果`nums[i]+nums[j]==k`，则保持i不变，去移动j，然后再判断是否和为k，但是其实一点道理都没有，反而会导致漏解，因为Alice是使目标最小化得分，她要做的就是选择与Bob不是互补的那个数，并不是说Alice就要按照大小从元素大的往下选，我靠我现在写题解也感觉自己当时为什么要这么想，好蠢啊！！！题做少了喵~

正确的题解：
其实这道题可以换个角度想，也就是先计算这个数组中有多少对可以凑成k并记录下来(ans)，然后min(ans,n/2)输出正确答案，是不是很简单，这里可以使用map快速映射然后遍历找到答案。

下面是主播错误的逻辑代码:
```cpp
for(int i = 0; i < n; i++){  
    if(p[k - q[i]] && p[q[i]]){  
        ans++;  
        p[k - q[i]]--;  
        p[q[i]]--;  
    }  
}

```
主播当时改正思路后的想法是先映射每个元素，然后遍历每个元素如果存在相应的补值，则补值和当前元素的键值-1，但是该代码在处理相同元素时会存在错误,如:



下面正确代码部分：
为什么检查完每个元素后不把相应的键值减掉？
因为每个元素只检查一次，因此不会导致重复情况出现

```cpp
 vector<int> q(n);  
    map<int , int> p;  
    for(int i = 0; i < n; i++){  
        cin >> q[i];  
        p[q[i]]++;  
    }  
    int ans = 0;  
    for(auto it = p.begin(); it != p.end(); ++it){  
        int num = it->first;  
        int num1 = k - num;  
        if(num1 < num) continue; //这里是为了防止重复配对
		
        if(p.count(num1)){ //检查键是否存在  
            if(num == num1){  
                ans += it->second / 2;  
            } else{  
                ans += min(it->second,p[num1]);  
            }  
        }  
    }  
    cout << min(ans,n / 2) << endl;  
}
```
**复杂度分析**:
1 ​**输入处理与频率统计**
```cpp
for(int i = 0; i < n; i++) {
        cin >> q[i];
        p[q[i]]++;  // map的插入操作是O(log m), m为不同元素的数量
    }。  
```
- 时间复杂度：`O(n log m)`，其中 `m` 是数组中不同元素的数量（`m ≤ n`）。
- 原因：`map`（红黑树实现）的插入和更新操作的时间复杂度是 `O(log m)`，需要执行 `n` 次
2. ​**遍历频率表计算配对数量**​
    ```cpp
    for(auto it = p.begin(); it != p.end(); ++it) {
        int num = it->first;
        int num1 = k - num;
        if (num1 < num) continue;
        if (p.count(num1)) {  // map的查找操作是O(log m)
            // ...
        }
    }
    ```
- 时间复杂度：`O(m log m)`，其中 `m` 是不同元素的数量。
- 原因：遍历所有 `m` 个不同元素，每次查找补数 `num1` 的操作需要`O(log m)` 时间。
3. ​**总时间复杂度**​
    - `O(n log m) + O(m log m) = O((n + m) log m)`。
    - 最坏情况下（所有元素不同，`m = n`），时间复杂度为 `O(n log n)`。